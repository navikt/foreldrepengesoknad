import{r as D,R as Z}from"./index-CTjT7uj6.js";const M={BASE_URL:"./",DEV:!1,MODE:"production",PROD:!0,SSR:!1,STORYBOOK:"true"};let x=0;function S(n,s){const r=`atom${++x}`,i={toString(){return(M?"production":void 0)!=="production"&&this.debugLabel?r+":"+this.debugLabel:r}};return typeof n=="function"?i.read=n:(i.init=n,i.read=m,i.write=nn),i}function m(n){return n(this)}function nn(n,s,r){return s(this,typeof r=="function"?r(n(this)):r)}const J=(n,s)=>n.unstable_is?n.unstable_is(s):s===n,F=n=>"init"in n,L=n=>!!n.write,B=new WeakMap,V=n=>{var s;return W(n)&&!((s=B.get(n))!=null&&s[1])},en=(n,s)=>{const r=B.get(n);if(r)r[1]=!0,r[0].forEach(i=>i(s));else if((M?"production":void 0)!=="production")throw new Error("[Bug] cancelable promise not found")},on=n=>{if(B.has(n))return;const s=[new Set,!1];B.set(n,s);const r=()=>{s[1]=!0};n.then(r,r),n.onCancel=i=>{s[0].add(i)}},W=n=>typeof(n==null?void 0:n.then)=="function",$=n=>"v"in n||"e"in n,a=n=>{if("e"in n)throw n.e;if((M?"production":void 0)!=="production"&&!("v"in n))throw new Error("[Bug] atom state is not initialized");return n.v},G=(n,s,r)=>{r.p.has(n)||(r.p.add(n),s.then(()=>{r.p.delete(n)},()=>{r.p.delete(n)}))},K=(n,s,r,i,b)=>{var k;if((M?"production":void 0)!=="production"&&i===s)throw new Error("[Bug] atom cannot depend on itself");r.d.set(i,b.n),V(r.v)&&G(s,r.v,b),(k=b.m)==null||k.t.add(s),n&&sn(n,i,s)},O=()=>[new Map,new Map,new Set],U=(n,s,r)=>{n[0].has(s)||n[0].set(s,new Set),n[1].set(s,r)},sn=(n,s,r)=>{const i=n[0].get(s);i&&i.add(r)},rn=(n,s)=>n[0].get(s),Y=(n,s)=>{n[2].add(s)},C=n=>{for(;n[1].size||n[2].size;){n[0].clear();const s=new Set(n[1].values());n[1].clear();const r=new Set(n[2]);n[2].clear(),s.forEach(i=>{var b;return(b=i.m)==null?void 0:b.l.forEach(k=>k())}),r.forEach(i=>i())}},H=n=>{let s;(M?"production":void 0)!=="production"&&(s=new Set);const r=(c,o,e)=>{const t="v"in o,l=o.v,u=V(o.v)?o.v:null;if(W(e)){on(e);for(const v of o.d.keys())G(c,e,n(v,o));o.v=e,delete o.e}else o.v=e,delete o.e;(!t||!Object.is(l,o.v))&&(++o.n,u&&en(u,e))},i=(c,o,e,t)=>{var l;if(!(t!=null&&t(o))&&$(e)&&(e.m||Array.from(e.d).every(([d,E])=>i(c,d,n(d,e),t).n===E)))return e;e.d.clear();let u=!0;const v=d=>{if(J(o,d)){const p=n(d,e);if(!$(p))if(F(d))r(d,p,d.init);else throw new Error("no atom init");return a(p)}const E=i(c,d,n(d,e),t);if(u)K(c,o,e,d,E);else{const p=O();K(p,o,e,d,E),f(p,o,e),C(p)}return a(E)};let h,_;const w={get signal(){return h||(h=new AbortController),h.signal},get setSelf(){return(M?"production":void 0)!=="production"&&!L(o)&&console.warn("setSelf function cannot be used with read-only atom"),!_&&L(o)&&(_=(...d)=>{if((M?"production":void 0)!=="production"&&u&&console.warn("setSelf function cannot be called in sync"),!u)return P(o,...d)}),_}};try{const d=o.read(v,w);if(r(o,e,d),W(d)){(l=d.onCancel)==null||l.call(d,()=>h==null?void 0:h.abort());const E=()=>{if(e.m){const p=O();f(p,o,e),C(p)}};d.then(E,E)}return e}catch(d){return delete e.v,e.e=d,++e.n,e}finally{u=!1}},b=c=>a(i(void 0,c,n(c))),k=(c,o,e)=>{var t,l;const u=new Map;for(const v of((t=e.m)==null?void 0:t.t)||[])u.set(v,n(v,e));for(const v of e.p)u.set(v,n(v,e));return(l=rn(c,o))==null||l.forEach(v=>{u.set(v,n(v,e))}),u},g=(c,o,e)=>{const t=[],l=new Set,u=(_,w)=>{if(!l.has(_)){l.add(_);for(const[d,E]of k(c,_,w))_!==d&&u(d,E);t.push([_,w,w.n])}};u(o,e);const v=new Set([o]),h=_=>l.has(_);for(let _=t.length-1;_>=0;--_){const[w,d,E]=t[_];let p=!1;for(const T of d.d.keys())if(T!==w&&v.has(T)){p=!0;break}p&&(i(c,w,d,h),f(c,w,d),E!==d.n&&(U(c,w,d),v.add(w))),l.delete(w)}},y=(c,o,e,...t)=>{const l=h=>a(i(c,h,n(h,e))),u=(h,..._)=>{const w=n(h,e);let d;if(J(o,h)){if(!F(h))throw new Error("atom not writable");const E="v"in w,p=w.v,T=_[0];r(h,w,T),f(c,h,w),(!E||!Object.is(p,w.v))&&(U(c,h,w),g(c,h,w))}else d=y(c,h,w,..._);return C(c),d};return o.write(l,u,...t)},P=(c,...o)=>{const e=O(),t=y(e,c,n(c),...o);return C(e),t},f=(c,o,e)=>{if(e.m&&!V(e.v)){for(const t of e.d.keys())e.m.d.has(t)||(R(c,t,n(t,e)).t.add(o),e.m.d.add(t));for(const t of e.m.d||[])if(!e.d.has(t)){e.m.d.delete(t);const l=j(c,t,n(t,e));l==null||l.t.delete(o)}}},R=(c,o,e)=>{if(!e.m){i(c,o,e);for(const t of e.d.keys())R(c,t,n(t,e)).t.add(o);if(e.m={l:new Set,d:new Set(e.d.keys()),t:new Set},(M?"production":void 0)!=="production"&&s.add(o),L(o)&&o.onMount){const t=e.m,{onMount:l}=o;Y(c,()=>{const u=l((...v)=>y(c,o,e,...v));u&&(t.u=u)})}}return e.m},j=(c,o,e)=>{if(e.m&&!e.m.l.size&&!Array.from(e.m.t).some(t=>{var l;return(l=n(t,e).m)==null?void 0:l.d.has(o)})){const t=e.m.u;t&&Y(c,t),delete e.m,(M?"production":void 0)!=="production"&&s.delete(o);for(const l of e.d.keys()){const u=j(c,l,n(l,e));u==null||u.t.delete(o)}return}return e.m},z={get:b,set:P,sub:(c,o)=>{const e=O(),t=n(c),l=R(e,c,t);C(e);const u=l.l;return u.add(o),()=>{u.delete(o);const v=O();j(v,c,t),C(v)}},unstable_derive:c=>H(...c(n))};return(M?"production":void 0)!=="production"&&Object.assign(z,{dev4_get_internal_weak_map:()=>({get:o=>{const e=n(o);if(e.n!==0)return e}}),dev4_get_mounted_atoms:()=>s,dev4_restore_atoms:o=>{const e=O();for(const[t,l]of o)if(F(t)){const u=n(t),v="v"in u,h=u.v;r(t,u,l),f(e,t,u),(!v||!Object.is(h,u.v))&&(U(e,t,u),g(e,t,u))}C(e)}}),z},tn=()=>{const n=new WeakMap;return H(r=>{let i=n.get(r);return i||(i={d:new Map,p:new Set,n:0},n.set(r,i)),i})};let A;const cn=()=>(A||(A=tn(),(M?"production":void 0)!=="production"&&(globalThis.__JOTAI_DEFAULT_STORE__||(globalThis.__JOTAI_DEFAULT_STORE__=A),globalThis.__JOTAI_DEFAULT_STORE__!==A&&console.warn("Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044"))),A),N={BASE_URL:"./",DEV:!1,MODE:"production",PROD:!0,SSR:!1,STORYBOOK:"true"},un=D.createContext(void 0),q=n=>D.useContext(un)||cn(),Q=n=>typeof(n==null?void 0:n.then)=="function",dn=n=>{n.status="pending",n.then(s=>{n.status="fulfilled",n.value=s},s=>{n.status="rejected",n.reason=s})},ln=Z.use||(n=>{if(n.status==="pending")throw n;if(n.status==="fulfilled")return n.value;throw n.status==="rejected"?n.reason:(dn(n),n)}),I=new WeakMap,fn=n=>{let s=I.get(n);return s||(s=new Promise((r,i)=>{let b=n;const k=P=>f=>{b===P&&r(f)},g=P=>f=>{b===P&&i(f)},y=P=>{"onCancel"in P&&typeof P.onCancel=="function"&&P.onCancel(f=>{if((N?"production":void 0)!=="production"&&f===P)throw new Error("[Bug] p is not updated even after cancelation");Q(f)?(I.set(f,s),b=f,f.then(k(f),g(f)),y(f)):r(f)})};n.then(k(n),g(n)),y(n)}),I.set(n,s)),s};function vn(n,s){const r=q(),[[i,b,k],g]=D.useReducer(f=>{const R=r.get(n);return Object.is(f[0],R)&&f[1]===r&&f[2]===n?f:[R,r,n]},void 0,()=>[r.get(n),r,n]);let y=i;if((b!==r||k!==n)&&(g(),y=r.get(n)),D.useEffect(()=>{const f=r.sub(n,()=>{g()});return g(),f},[r,n,void 0]),D.useDebugValue(y),Q(y)){const f=fn(y);return ln(f)}return y}function hn(n,s){const r=q();return D.useCallback((...b)=>{if((N?"production":void 0)!=="production"&&!("write"in n))throw new Error("not writable atom");return r.set(n,...b)},[r,n])}const X=S("blue"),pn=()=>vn(X),En=n=>{const s=hn(X);D.useEffect(()=>{s(n)},[s,n])};export{pn as a,S as b,hn as c,vn as d,En as u};
